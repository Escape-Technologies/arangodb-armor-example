'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var graphql = require('graphql');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

const costLimitDefaultOptions = {
  maxCost: 5000,
  objectCost: 2,
  scalarCost: 1,
  depthCostFactor: 1.5,
  ignoreIntrospection: true
};

class CostLimitVisitor {
  constructor(context, onError, options) {
    _defineProperty(this, "OperationDefinition", void 0);

    _defineProperty(this, "context", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "onError", void 0);

    this.context = context;
    this.config = Object.assign({}, costLimitDefaultOptions, ...Object.entries(options !== null && options !== void 0 ? options : {}).map(([k, v]) => v === undefined ? {} : {
      [k]: v
    }));
    this.onError = onError;
    this.OperationDefinition = {
      enter: this.onOperationDefinitionEnter
    };
  }

  onOperationDefinitionEnter(operation) {
    const complexity = this.computeComplexity(operation);

    if (complexity > this.config.maxCost) {
      this.onError(`Query is too expensive.`);
    }
  }

  computeComplexity(node, depth = 0) {
    var _node$name;

    if (this.config.ignoreIntrospection && 'name' in node && ((_node$name = node.name) === null || _node$name === void 0 ? void 0 : _node$name.value) === '__schema') {
      return 0;
    } // const typeDefs: GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType = this.context
    // .getSchema()
    // .getQueryType();


    let cost = this.config.scalarCost;

    if ('selectionSet' in node && node.selectionSet) {
      cost = this.config.objectCost;

      for (let child of node.selectionSet.selections) {
        cost += this.config.depthCostFactor * this.computeComplexity(child, depth + 1);
      }
    }

    if (node.kind == graphql.Kind.FRAGMENT_SPREAD) {
      const fragment = this.context.getFragment(node.name.value);

      if (fragment) {
        cost += this.config.depthCostFactor * this.computeComplexity(fragment, depth + 1);
      }
    }

    return cost;
  }

}

const costLimitRule = (errorHandler, options) => context => new CostLimitVisitor(context, errorHandler, options);

const costLimitPlugin = options => {
  return {
    onValidate({
      addValidationRule
    }) {
      addValidationRule(costLimitRule(msg => {
        throw new graphql.GraphQLError(msg);
      }, options));
    }

  };
};

exports.costLimitPlugin = costLimitPlugin;
exports.costLimitRule = costLimitRule;
